This algorithm is a clever and efficient way to solve problems that can be modeled as a linked list with a cycle, with O(n) time and O(1) space. It is applicable to any problem where you have a sequence of states generated by x_next = f(x_previous), but we mainly focus on cycle detection here. 


## Example Question
Let's take Find the Duplicate Number as an example. 

You are given an array of integers nums containing n + 1 integers. Each integer in nums is in the range [1, n] inclusive.
Every integer appears exactly once, except for one integer which appears two or more times. Return the integer that appears more than once.

Our target is solving the problem without modifying the array nums and using O(1) extra space. Making a Python dictionary is a standard choice, but it require O(n) space.
Alternatively, Floyd algorithm can provide a better solution.

## Math Proof
There are two phases in this script. One, finding if the cycle exsist. We handle the element in array with twin pointers' property. Since the key difference between index and elements
is the duplicate in element, when both slow and fast pointer share same value, it means they already in the cycle, and we call that point as meeting point.

The next phase is find the entrance of cycle, which must be the duplicate element. The meeting point is not always equal to entrance, but we have a solid way to find it.
We move the slow point to the initial position and note the distance from start point to cycle's entrance as L, the perimeter of cycle as C and the distance from entrance to 
the meeting point as K. In last phase, the travel distance of two pointers can be summarize as this formula 2 * (L + K) = L + K + a * C. a is a coefficient, which means fast pointer may finished few completed cycle, but eventually stop at meeting point. After simplification, we have L = a*C - K. Here, a is the coeffeicent of a cycle, so we can remove it, and get L = C - K.
In other words, the distance from initial point to the entrance, is the equal to the distance from meeting point to the entrance. So we can reset the slow pointer to start point, and move
both pointer foward(fast is still in meeting point), then they will finally meet at entrance, which is the place of duplicate.

## Python Code

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:

    #Phase 1
    slow = nums[0]
    fast = nums[0]

    while True:
      slow = nums[slow]
      fast = nums[nums[fast]]

      if slow == fast:
        break

      #Phase 2
      slow = nums[0]

      while slow != fast:
        slow = nums[slow]
        fast = nums[fast]

      return slow


