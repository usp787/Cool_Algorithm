This algorithm is a clever and efficient way to solve problems that can be modeled as a linked list with a cycle, with O(n) time and O(1) space. It is applicable to any problem where you have a sequence of states generated by x_next = f(x_previous), but we mainly focus on cycle detection here. 


## Code Example
Let's take Find the Duplicate Number as an example. 

You are given an array of integers nums containing n + 1 integers. Each integer in nums is in the range [1, n] inclusive.
Every integer appears exactly once, except for one integer which appears two or more times. Return the integer that appears more than once.

Our target is solving the problem without modifying the array nums and using O(1) extra space. Making a Python dictionary is a standard choice, but it require O(n) space.
Alternatively, Floyd algorithm can provide a better solution.

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:

    #Phase 1
    slow = nums[0]
    fast = nums[0]

    while True:
      slow = nums[slow]
      fast = nums[nums[fast]]

      if slow == fast:
        break

      #Phase 2
      slow = nums[0]

      while slow != fast:
        slow = nums[slow]
        fast = nums[fast]

      return slow

  Test example
  Input: nums = [1,2,3,2,2]  Output: 2
