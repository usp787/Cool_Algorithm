This algorithm is a clever and efficient way to solve problems that can be modeled as a linked list with a cycle, with O(n) time and O(1) space. It is applicable to any problem where you have a sequence of states generated by x_next = f(x_previous), but here we mainly focus on cycle detection.


## Example Problem: Find the Duplicate Number
You are given an array of integers nums containing n + 1 integers. Each integer in nums is in the range [1, n] inclusive.
Every integer appears exactly once, except for one integer which appears two or more times. Return the integer that appears more than once.

Our goal is solving the problem without modifying the array nums and using O(1) extra space. Using a Python dictionary or set is a standard option, but that require O(n) space.
Instead, Floyd algorithm give us a better solution.

## Math Proof
There are two phases in this script. 

The first pahse is finding if the cycle exist. We handle the element in array with double pointers' approach. Since the key difference between index and elements
is the duplicate in element, when both slow and fast pointer have the same value, it means they already in the cycle, and we call that point as meeting point.

The next phase is find the entrance of cycle, which must be the duplicate element. The meeting point is not always equal to entrance, but we have a solid way to find it.
We reset the slow pointer to the start and note the distance from start point to cycle's entrance as L, the perimeter of cycle as C and the distance from entrance to 
the meeting point as K. In last phase, the travel distance of two pointers can be summarized as this formula 2 * (L + K) = L + K + a * C. a is a coefficient, which means fast pointer may finished few completed cycle, but eventually stop at meeting point. After simplification, we have L = a*C - K. 

Here, how to treat a * C is not so intuitive. In fact, it can be paraphrased as 'travel completed cycles with a times', which means you still in the same position! So the formula can 
be simplifed as L = C - K. In other words, the distance from initial point to the entrance, is the equal to the distance from meeting point to the entrance. So we move both pointers foward(fast is still in meeting point), then they will finally meet at entrance, which is the place of duplicate.

## Python Code

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # Phase 1: Finding the intersection point
        slow = nums[0]
        fast = nums[0]

        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break

        # Phase 2: Finding the entrance to the cycle
        slow = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]

        return slow



